# Keep your business logic clean

Composable Functions with schema helps you decouple your business logic from your controllers, with first-class type inference from end to end.
It does this by enforcing the parameters' types at runtime (through [Zod](https://github.com/colinhacks/zod#what-is-zod) schemas) and always wrapping results (even exceptions) into a `Promise<Result<Output>>` type.

![](example.gif)

## Table of contents
- [Benefits](#benefits)
- [Quickstart](#quickstart)
- [Using Deno](#using-deno)
- [Taking parameters that are not user input](#taking-parameters-that-are-not-user-input)
- [Dealing with errors](#dealing-with-errors)
  - [Changing the ErrorResult with Custom Errors](#changing-the-errorresult-with-custom-errors)
  - [Tracing](#tracing)
- [Combining functions](#combining-functions)
  - [all](#all)
  - [collect](#collect)
  - [pipe](#pipe)
  - [sequence](#sequence)
  - [branch](#branch)
  - [map](#map)
  - [mapError](#maperror)
- [Extracting input values for composables with schema](#extracting-input-values-for-composables-with-schema)
  - [inputFromForm](#inputfromform)
  - [inputFromFormData](#inputfromformdata)
  - [inputFromUrl](#inputfromurl)
  - [inputFromSearch](#inputfromsearch)
- [FAQ](#faq)


## Benefits

- Provides end-to-end type safety, all the way from the Backend to the UI
- Removes the "plumbing": Extracting and parsing structured data from your Requests
- Keeps your functions decoupled from the framework, with the assurance that your values conform to your types
- Facilitates easier testing and maintainence of business logic
- Allows business logic to be expressed in the type system

## Quickstart

```
npm i composable-functions zod
```

```tsx
import { withSchema, inputFromForm } from 'composable-functions'
import * as z from 'zod'

const schema = z.object({ number: z.coerce.number() })
const increment = withSchema(schema)(({ number }) => number + 1)

const result = await increment({ number: 1 })
/*
result = {
  success: true,
  data: 2,
  errors: []
}
*/
const failedResult = await increment({ number: 'foo' })
/*
failedResult = {
  success: false,
  errors: [new InputError('Expected number, received nan', ['number'])],
}
*/
```

To understand how to build the schemas, refer to [Zod documentation](https://github.com/colinhacks/zod#defining-schemas).

## Using Deno

If you are using [Deno](https://deno.land/), just directly import the functions you need from [deno.land/x](https://deno.land/x):

```ts
import { withSchema } from "https://deno.land/x/composable_functions/mod.ts";
```

This documentation will use Node.JS imports by convention, just replace `composable-functions` with `https://deno.land/x/composable_functions/mod.ts` when using [Deno](https://deno.land/).

## Taking parameters that are not user input

Sometimes you want to ensure the safety of certain values that weren't explicitly sent by the user. We call them _environment_:

```tsx
// In some app/business/*.server.ts file
const sendEmail = withSchema(
  z.object({ email: z.string().email() }), // user input schema
  z.object({ origin: z.string() }) // environment schema
)(
  async ({ email }, { origin }) => {
    mailer.send({
      email,
      message: `Link to reset password: ${origin}/reset-password`
    })
  }
)

// In your controller:
async ({ request }) => {
  const environment = (request: Request) => ({
    origin: new URL(request.url).origin,
  })

  await sendEmail(
    await inputFromForm(request),
    environment(request),
  )
}
```

We usually use the environment for ensuring authenticated requests.
In this case, assume you have a `currentUser` function that returns the authenticated user:

```tsx
const dangerousFunction = withSchema(
  someInputSchema,
  z.object({ user: z.object({ id: z.string(), admin: z.literal(true) }) })
)(async (input, { user }) => {
  // do something that only the admin can do
})
```

## Dealing with errors

The error result has the following structure:

```ts
type ErrorResult = {
  success: false
  errors: Error[]
}
```

There's the `InputError` and `EnvironmentError` constructors with errors from parsing the corresponding Zod schemas, and the other `Error` for any exceptions thrown inside the composable.

```ts
const alwaysFails = withSchema(input, environment)(async () => {
  throw new Error('Some error')
})

const failedResult = await alwaysFails(someInput)
/*
failedResult = {
  success: false,
  errors: [
    new Error('Some error'),
    new InputError('Expected number, received nan', ['age']),
    new EnvironmentError('Expected number, received nan', ['id']),
  ],
}
*/
```

### Changing the ErrorResult with Custom Errors

You can throw an `InputError` whenever you want a custom input error that cannot be generated by your schema.

```ts
const alwaysFails = withSchema(input, environment)(async () => {
  throw new InputError('Email already taken', ['email'])
})

const failedResult = await alwaysFails(someInput)
//    ^? Result<never>
/*
failedResult = {
  success: false,
  errors: [new InputError('Email already taken', ['email'])],
}
*/
```

You can also return a custom environment error by throwing an `EnvironmentError`.

<!-- TODO: talk about serialize -->
<!-- ### Using error messages in the UI

To improve DX when dealing with errors, we export a couple of utilities. -->

### Tracing

Whenever you need to intercept inputs and a composable result without changing them, there is a function called `trace` that can help you.

The most common use case is to log failures to the console or to an external service. Let's say you want to log failed composables, you could create a function such as this:

```ts
const traceToConsole = trace((context) => {
  if(!context.result.success) {
    console.trace("Composable Failure ", context)
  }
})
```

Then, assuming you want to trace all failures in a `someOtherFunction`, you just need to pass that composable to our `tracetoConsole` function:

```ts
traceToConsole(someOtherFunction)()
```

It would also be simple to create a function that will send the errors to some error tracking service under certain conditions:

```ts
const trackErrors = trace(async ({ input, output, result }) => {
  if(!result.success && someOtherConditions(result)) {
    await sendToExternalService({ input, output, result })
  }
})
```

## Combining functions

These combinators are useful for composing functions. They all return another `Composable`, thus allowing further application in more compositions.

### all

`all` creates a single composable out of multiple composables.
It will pass the same input and environment to each provided function.
If __all constituent functions__ are successful, The `data` field (on the composite function's result) will be a tuple containing each function's output.

```ts
const a = withSchema(z.object({ id: z.number() }))(({ id }) => String(id))
const b = withSchema(z.object({ id: z.number() }))(({ id }) => id + 1)
const c = withSchema(z.object({ id: z.number() }))(({ id }) => Boolean(id))

const results = await all(a, b, c)({ id: 1 })
//    ^? Result<[string, number, boolean]>
```

For the example above, the result will be:

```ts
{
  success: true,
  data: ['1', 2, true],
  errors: [],
}
```

If any of the constituent functions fail, the `errors` field (on the composite function's result) will be an array of the concatenated errors from each failing function:

```ts
const a = withSchema(z.object({ id: z.number() }))(() => {
  throw new Error('Error A')
})
const b = withSchema(z.object({ id: z.number() }))(() => {
  throw new Error('Error B')
})

const results = await all(a, b)({ id: 1 })
//    ^? Result<[never, never]>

/*{
  success: false,
  errors: [new Error('Error A'), new Error('Error B')],
}*/
```

### collect

`collect` works like the `all` function but receives its constituent functions inside a record with string keys that identify each one. The shape of this record will be preserved for the `data` property in successful results.

The motivation for this is that an object with named fields is often preferable to long tuples, when composing many composables.

```ts
const a = withSchema(z.object({}))(() => '1')
const b = withSchema(z.object({}))(() => 2)
const c = withSchema(z.object({}))(() => true)

const results = await collect({ a, b, c })({})
//    ^? Result<{ a: string, b: number, c: boolean }>
```

For the example above, the result will be:

```ts
{
  success: true,
  data: { a: '1', b: 2, c: true },
  errors: [],
}
```

As with the `all` function, in case any function fails their errors will be concatenated.

### pipe

`pipe` creates a single composable out of a chain of multiple composables.
It will pass the same environment to all given functions, and it will pass the output of a function as the next function's input in left-to-right order.
The resulting data will be the output of the rightmost function.

Note that there is no type-level assurance that a function's output will align with and be succesfully parsed by the next function in the pipeline.

```ts
const a = withSchema(z.object({ aNumber: z.number() }))(
  ({ aNumber }) => ({
    aString: String(aNumber),
  }),
)
const b = withSchema(z.object({ aString: z.string() }))(
  ({ aString }) => ({
    aBoolean: aString == '1',
  }),
)
const c = withSchema(z.object({ aBoolean: z.boolean() }))(
  async ({ aBoolean }) => !aBoolean,
)

const d = pipe(a, b, c)

const result = await d({ aNumber: 1 })
//    ^? Result<boolean>
```

For the example above, the result will be:

```ts
{
  success: true,
  data: false,
  errors: [],
}
```

If one functions fails, execution halts and the error is returned.

### sequence

`sequence` works exactly like the `pipe` function, except __the shape of the result__ is different.
Instead of the `data` field being the output of the last composable, it will be a tuple containing each intermediate output (similar to the `all` function).

```ts
const a = withSchema(z.number())((aNumber) => String(aNumber))
const b = withSchema(z.string())((aString) => aString === '1')

const c = sequence(a, b)

const result = await c(1)
//    ^? Result<[string, boolean]>
```

For the example above, the result will be:

```ts
{
  success: true,
  data: ['1', true],
  errors: [],
}
```

If you'd rather have an object instead of a tuple, you can use the `map` and `mergeObjects` functions like so:

```ts
import { mergeObjects } from 'composable-functions'

const a = withSchema(z.number())((aNumber) => ({
  aString: String(aNumber)
}))
const b = withSchema(z.object({ aString: z.string() }))(
  ({ aString }) => ({ aBoolean: aString === '1' })
)

const c = map(sequence(a, b), mergeObjects)

const result = await c(1)
//    ^? Result<{ aString: string, aBoolean: boolean }>
```

### branch

Use `branch` to add conditional logic to your composables' compositions.

It receives a composable and a predicate function that should return the next composable to be executed based on the previous function's output, like `pipe`.

```ts
const getIdOrEmail = withSchema(z.object({ id: z.number().optional, email: z.string().optional() }))((data) => {
  return data.id ?? data.email
})
const findUserById = withSchema(z.number())((id) => {
  return db.users.find({ id })
})
const findUserByEmail = withSchema(z.string().email())((email) => {
  return db.users.find({ email })
})
const findUserByIdOrEmail = branch(
  getIdOrEmail,
  (output) => (typeof output === "number" ? findUserById : findUserByEmail),
)
const result = await findUserByIdOrEmail({ id: 1 })
//    ^? Result<User>
```
For the example above, the result will be:
```ts
{
  success: true,
  data: { id: 1, email: 'john@doe.com' },
  errors: [],
}
```
If you don't want to pipe when a certain condition is matched, you can return `null` like so:
```ts
const a = withSchema()(() => 'a')
const b = withSchema()(() => 'b')
const aComposable = branch(a, (output) => output === 'a' ? null : b)
//    ^? Composable<(i: unknown, e: unknown) => 'a' | 'b'>
```

If any function fails, execution halts and the error is returned.
The predicate function will return an `ErrorResult` type in case it throws:
```ts
const findUserByIdOrEmail = branch(
  getIdOrEmail,
  (output) => {
    throw new Error("Invalid input")
  },
)
//    ^? Composable<(i: unknown, e: unknown) => never>
```
For the example above, the result type will be `ErrorResult`:
```ts
{ success: false, errors: [new Error('Invalid input')] }
```

### map

`map` creates a single composable that will apply a transformation over the `result.data` of a successful `Composable`.
When the given composable fails, its error is returned wihout changes.
If successful, the `data` field will contain the output of the first function argument, mapped using the second function argument.

This can be useful when composing functions. For example, you might need to align input/output types in a pipeline:

```ts
const fetchAsText = withSchema(z.object({ userId: z.number() }))(
  ({ userId }) =>
    fetch(`https://reqres.in/api/users/${String(userId)}`).then((r) =>
      r.json(),
    ),
)

const fullName = withSchema(
  z.object({ first_name: z.string(), last_name: z.string() }),
)(({ first_name, last_name }) => `${first_name} ${last_name}`)

const fetchFullName = pipe(
  map(fetchAsText, ({ data }) => data),
  fullName,
)

const result = fetchFullName({ userId: 2 })
//    ^? Result<string>
```

For the example above, the result will be something like this:

```ts
{
  success: true,
  data: 'Janet Weaver',
  errors: [],
}
```

### mapError

`mapError` creates a single composable that will apply a transformation over the `Failure` of a failed `Composable`.
When the given composable succeeds, its result is returned without changes.

This could be useful when adding any layer of error handling.
In the example below, we are counting the errors but disregarding the contents:

```ts
const increment = withSchema(z.object({ id: z.number() }))(
  ({ id }) => id + 1,
)

const summarizeErrors = (result: Error[]) =>
  [new Error('Number of errors: ' + result.errors.length)]

const incrementWithErrorSummary = mapError(increment, summarizeErrors)

const result = await incrementWithErrorSummary({ invalidInput: '1' })
```

For the example above, the `result` will be:

```ts
{
  success: false,
  errors: [new Error('Number of errors: 1')],
}
```

## Extracting input values for composables with schema

We export some functions to help you extract values out of your requests before sending them as user input.

These functions are better suited for use with `withSchema` rather than `composable` since they deal with external data and `withSchema` will ensure type-safety in runtime.

### inputFromForm

`inputFromForm` will read a request's `FormData` and extract its values into a structured object:

```tsx
// Given the following form:
function Form() {
  return (
    <form method="post">
      <input name="email" value="john@doe.com" />
      <input name="password" value="1234" />
      <button type="submit">
        Submit
      </button>
    </form>
  )
}

async (request: Request) => {
  const values = await inputFromForm(request)
  // values = { email: 'john@doe.com', password: '1234' }
}
```

### inputFromFormData

`inputFromFormData` extracts values from a `FormData` object into a structured object:

```tsx
const formData = new FormData()
formData.append('email', 'john@doe.com')
formData.append('tasks[]', 'one')
formData.append('tasks[]', 'two')
const values = inputFromFormData(formData)
// values = { email: 'john@doe.com', tasks: ['one', 'two'] }
```

### inputFromUrl

`inputFromUrl` will read a request's query params and extract its values into a structured object:

```tsx
// Given the following form:
function Form() {
  return (
    <form method="get">
      <button name="page" value="2">
        Change URL
      </button>
    </form>
  )
}

async (request: Request) => {
  const values = inputFromUrl(request)
  // values = { page: '2' }
}
```
### inputFromSearch

`inputFromSearch` extracts values from a `URLSearchParams` object into a structured object:

```tsx
const qs = new URLSearchParams()
qs.append('colors[]', 'red')
qs.append('colors[]', 'green')
qs.append('colors[]', 'blue')
const values = inputFromSearch(qs)
// values = { colors: ['red', 'green', 'blue'] }
```

All of the functions above will allow structured data as follows:

```tsx
// Given the following form:
function Form() {
  return (
    <form method="post">
      <input name="numbers[]" value="1" />
      <input name="numbers[]" value="2" />
      <input name="person[0][email]" value="john@doe.com" />
      <input name="person[0][password]" value="1234" />
      <button type="submit">
        Submit
      </button>
    </form>
  )
}

async (request: Request) => {
  const values = await inputFromForm(request)
  /*
  values = {
    numbers: ['1', '2'],
    person: [{ email: 'john@doe.com', password: '1234' }]
  }
  */
}
```

To better understand how to structure your data, refer to [this test file](./src/input-resolvers.test.ts)

## FAQ

- I want to use composable-functions in a project that does not have Zod, how can I use other schema validation libraries?
  - We created an example in the example folder showing how to construct your own `withSchema` functions based on other parsers.
